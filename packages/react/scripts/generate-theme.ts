/**
 * Generate Tailwind v4 Theme from \@prism/tokens
 *
 * This script converts our TypeScript design tokens into CSS custom properties
 * that Tailwind v4 can consume via the \@theme directive.
 *
 * Why this approach?
 * - Single source of truth: \@prism/tokens (TypeScript)
 * - Tailwind v4 uses CSS-first configuration
 * - This script bridges the two systems
 * - Tokens remain type-safe and shareable across packages
 */

import { writeFileSync } from "node:fs";
import { join } from "node:path";

import {
  borderRadius,
  borderWidth,
  colors,
  shadows,
  sizes,
  spacing,
  transitions,
  typography,
} from "@prism/tokens";

/**
 * Generate theme CSS with custom \@source paths
 *
 * @param sourcePaths - Array of relative paths for \@source directive
 */
function generateThemeCSS(sourcePaths: string[]): string {
  let css = `/**
 * Prism Design System - Tailwind Theme
 *
 * Auto-generated from @prism/tokens
 * DO NOT EDIT THIS FILE MANUALLY
 *
 * To modify theme values, edit packages/tokens/src/*
 * Then run: pnpm generate:theme
 */

@import "tailwindcss";

/**
 * @source directive tells Tailwind v4 where to scan for class names.
 * This replaces the 'content' array from Tailwind v3 config files.
 *
 * Educational note:
 * - Scans our React components for classes like 'bg-primary-500'
 * - Scans Storybook stories for usage examples
 * - Tailwind generates ONLY the utilities it finds in these files (tree-shaking)
 */
`;

  // Add @source directives
  sourcePaths.forEach((path) => {
    css += `@source "${path}";\n`;
  });

  css += `\n@theme {\n`;

  // Generate color variables
  css += `  /* Primary Colors */\n`;
  Object.entries(colors.primary).forEach(([key, value]) => {
    css += `  --color-primary-${key}: ${value};\n`;
  });

  css += `\n  /* Neutral Colors */\n`;
  Object.entries(colors.neutral).forEach(([key, value]) => {
    css += `  --color-neutral-${key}: ${value};\n`;
  });

  css += `\n  /* Semantic Colors - Success */\n`;
  Object.entries(colors.success).forEach(([key, value]) => {
    css += `  --color-success-${key}: ${value};\n`;
  });

  css += `\n  /* Semantic Colors - Error */\n`;
  Object.entries(colors.error).forEach(([key, value]) => {
    css += `  --color-error-${key}: ${value};\n`;
  });

  css += `\n  /* Semantic Colors - Warning */\n`;
  Object.entries(colors.warning).forEach(([key, value]) => {
    css += `  --color-warning-${key}: ${value};\n`;
  });

  css += `\n  /* Semantic Colors - Info */\n`;
  Object.entries(colors.info).forEach(([key, value]) => {
    css += `  --color-info-${key}: ${value};\n`;
  });

  // Generate spacing variables
  css += `\n  /* Spacing Scale (4px base) */\n`;
  Object.entries(spacing).forEach(([key, value]) => {
    css += `  --spacing-${key}: ${value};\n`;
  });

  // Generate typography variables - font sizes
  css += `\n  /* Font Sizes */\n`;
  Object.entries(typography.fontSize).forEach(([key, value]) => {
    css += `  --font-size-${key}: ${value};\n`;
  });

  // Generate typography variables - font weights
  css += `\n  /* Font Weights */\n`;
  Object.entries(typography.fontWeight).forEach(([key, value]) => {
    css += `  --font-weight-${key}: ${value};\n`;
  });

  // Generate typography variables - line heights
  css += `\n  /* Line Heights */\n`;
  Object.entries(typography.lineHeight).forEach(([key, value]) => {
    css += `  --line-height-${key}: ${value};\n`;
  });

  // Generate border radius variables
  css += `\n  /* Border Radius */\n`;
  Object.entries(borderRadius).forEach(([key, value]) => {
    css += `  --radius-${key}: ${value};\n`;
  });

  // Generate shadow variables
  css += `\n  /* Shadows */\n`;
  Object.entries(shadows).forEach(([key, value]) => {
    css += `  --shadow-${key}: ${value};\n`;
  });

  // Generate size variables
  css += `\n  /* Sizes */\n`;
  Object.entries(sizes).forEach(([key, value]) => {
    css += `  --size-${key}: ${value};\n`;
  });

  // Generate border width variables
  css += `\n  /* Border Widths */\n`;
  Object.entries(borderWidth).forEach(([key, value]) => {
    const cssKey = key === "DEFAULT" ? "default" : key;
    css += `  --border-width-${cssKey}: ${value};\n`;
  });

  // Generate transition duration variables
  css += `\n  /* Transition Durations */\n`;
  Object.entries(transitions.duration).forEach(([key, value]) => {
    css += `  --duration-${key}: ${value};\n`;
  });

  // Generate transition timing function variables
  css += `\n  /* Transition Timing Functions */\n`;
  Object.entries(transitions.timing).forEach(([key, value]) => {
    css += `  --ease-${key}: ${value};\n`;
  });

  css += `}\n`;

  return css;
}

// Generate and write theme files to multiple locations
const outputs = [
  {
    path: join(__dirname, "..", "src", "styles", "theme.css"),
    sourcePaths: [
      "../**/*.{ts,tsx}", // Scan packages/react/src from packages/react/src/styles/
      "../../../../apps/docs/stories/**/*.{ts,tsx}", // Scan Storybook stories
    ],
  },
  {
    path: join(
      __dirname,
      "..",
      "..",
      "..",
      "apps",
      "docs",
      ".storybook",
      "prism.css",
    ),
    sourcePaths: [
      "../../../packages/react/src/**/*.{ts,tsx}", // Scan React components from apps/docs/.storybook/
      "../stories/**/*.{ts,tsx}", // Scan Storybook stories
    ],
  },
];

outputs.forEach(({ path, sourcePaths }) => {
  const themeCSS = generateThemeCSS(sourcePaths);
  writeFileSync(path, themeCSS, "utf-8");
  // eslint-disable-next-line no-console -- CLI output for build script
  console.log(`âœ… Generated: ${path}`);
});

// eslint-disable-next-line no-console -- CLI output for build script
console.log("\nðŸŽ¨ Theme generation complete from @prism/tokens");
